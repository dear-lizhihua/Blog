(self.webpackChunk_site_blog=self.webpackChunk_site_blog||[]).push([[1730],{3905:function(e,n,t){"use strict";t.d(n,{Zo:function(){return p},kt:function(){return h}});var r=t(7294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,r,a=function(e,n){if(null==e)return{};var t,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)t=i[r],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)t=i[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var c=r.createContext({}),d=function(e){var n=r.useContext(c),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},p=function(e){var n=d(e.components);return r.createElement(c.Provider,{value:n},e.children)},s={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},u=r.forwardRef((function(e,n){var t=e.components,a=e.mdxType,i=e.originalType,c=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),u=d(t),h=a,m=u["".concat(c,".").concat(h)]||u[h]||s[h]||i;return t?r.createElement(m,o(o({ref:n},p),{},{components:t})):r.createElement(m,o({ref:n},p))}));function h(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var i=t.length,o=new Array(i);o[0]=u;var l={};for(var c in n)hasOwnProperty.call(n,c)&&(l[c]=n[c]);l.originalType=e,l.mdxType="string"==typeof e?e:a,o[1]=l;for(var d=2;d<i;d++)o[d]=t[d];return r.createElement.apply(null,o)}return r.createElement.apply(null,t)}u.displayName="MDXCreateElement"},2989:function(e,n,t){"use strict";t.r(n),t.d(n,{frontMatter:function(){return l},contentTitle:function(){return c},metadata:function(){return d},toc:function(){return p},default:function(){return u}});var r=t(2122),a=t(9756),i=(t(7294),t(3905)),o=["components"],l={id:"you_might_not_need_that_recursive_function_in_javascript_en",title:"You Might Not Need that Recursive Function in JavaScript"},c=void 0,d={unversionedId:"core/detail/you_might_not_need_that_recursive_function_in_javascript_en",id:"core/detail/you_might_not_need_that_recursive_function_in_javascript_en",isDocsHomePage:!1,title:"You Might Not Need that Recursive Function in JavaScript",description:"In programming, we\u2019re often faced with situations where the answer appears to require solving the same problem an indeterminate number of times. When we encounter a problem like this, we tend to reach for recursion \u2014 often accomplished by creating a function that calls itself as many times as necessary. Recursion is extremely important in programming and many problems can only be solved by using it. That being said, recursion can be slower, fill up the call stack, and can be conceptually trickier.",source:"@site/docs/core/detail/you_might_not_need_that_recursive_function_in_javascript_en.md",sourceDirName:"core/detail",slug:"/core/detail/you_might_not_need_that_recursive_function_in_javascript_en",permalink:"/blog/docs/core/detail/you_might_not_need_that_recursive_function_in_javascript_en",editUrl:"https://github.com/facebook/docusaurus/edit/master/website/docs/core/detail/you_might_not_need_that_recursive_function_in_javascript_en.md",version:"current",frontMatter:{id:"you_might_not_need_that_recursive_function_in_javascript_en",title:"You Might Not Need that Recursive Function in JavaScript"}},p=[{value:"The Problem",id:"the-problem",children:[]},{value:"The Solution",id:"the-solution",children:[]}],s={toc:p};function u(e){var n=e.components,l=(0,a.Z)(e,o);return(0,i.kt)("wrapper",(0,r.Z)({},s,l,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"In programming, we\u2019re often faced with situations where the answer appears to require solving the same problem an indeterminate number of times. When we encounter a problem like this, we tend to reach for recursion \u2014 often accomplished by creating a function that calls itself as many times as necessary. Recursion is extremely important in programming and many problems can only be solved by using it. That being said, recursion can be slower, fill up the call stack, and can be conceptually trickier."),(0,i.kt)("p",null,"In this post, I will explore an example of a problem that seems to lend itself to a recursive solution, but can in fact be solved more efficiently through an understanding of JavaScript object references. The motivation for this post example came from an excellent ",(0,i.kt)("a",{parentName:"p",href:"https://stackoverflow.com/a/18018037/6525724"},"StackOverflow answer")," that I have adapted."),(0,i.kt)("h2",{id:"the-problem"},"The Problem"),(0,i.kt)("p",null,"In this problem, we are attempting to build a hierarchical object tree structure based on a flat array of objects. We do not know ahead of time how deep the tree will be, but we know that each node can only have one parent and can have any number of children. A visualization of an example tree we can work with is as follows:"),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"Example Tree Structure",src:t(8580).Z})),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"(Example Tree Structure)")),(0,i.kt)("p",null,"As mentioned, the data we receive to build this tree example is a flattened array in the following format. Each element represents one node of the tree and can be the child of only one parent node. Node 8 has no parent, so we can see in the array below that the object for ",(0,i.kt)("inlineCode",{parentName:"p"},"id")," 8 has a ",(0,i.kt)("inlineCode",{parentName:"p"},"parentId")," equal to ",(0,i.kt)("inlineCode",{parentName:"p"},"null"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"const flat = [\n  { id: 1, parentId: 3 },\n  { id: 3, parentId: 8 },\n  { id: 4, parentId: 6 },\n  { id: 6, parentId: 3 },\n  { id: 7, parentId: 6 },\n  { id: 8, parentId: null },\n  { id: 10, parentId: 8 }, \n  { id: 13, parentId: 14 },\n  { id: 14, parentId: 10 }\n]\n")),(0,i.kt)("p",null,"The final structure we need to rearrange this flat array into is as follows:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"[\n  { \n    id: 8,\n    children: [\n      { \n        id: 3, \n        children: [\n          { \n            id: 1, \n            children: [] \n          }, \n          { \n            id: 6, \n            children: [ \n              { id: 4, children: [] }, \n              { id: 7, children: [] } \n            ]\n          }\n        ] \n      },\n      { \n        id: 10, \n        children: [ \n          { \n            id: 14, \n            children: [\n              { id: 13, children: [] }\n            ] \n          }\n        ]\n      }\n    ]\n  }\n]\n")),(0,i.kt)("h2",{id:"the-solution"},"The Solution"),(0,i.kt)("p",null,"Your first inkling in this scenario might be to reach for recursion: we\u2019re given a tree of indeterminate length. We imagine we might have to create a function that populates a node\u2019s children. Then, we recursively call that function until the tree is fully populated and (i.e., no more child nodes are found)."),(0,i.kt)("p",null,"While this would probably work, there is a better way!"),(0,i.kt)("p",null,"We can simply iterate through the array and assign each object to the ",(0,i.kt)("inlineCode",{parentName:"p"},"children")," array of its parent object. This may not make intuitive sense, but consider this logic:"),(0,i.kt)("p",null,"Object ",(0,i.kt)("inlineCode",{parentName:"p"},"3")," is assigned to the ",(0,i.kt)("inlineCode",{parentName:"p"},"children")," array of object ",(0,i.kt)("inlineCode",{parentName:"p"},"8")),(0,i.kt)("p",null,"Object ",(0,i.kt)("inlineCode",{parentName:"p"},"6")," is assigned to the ",(0,i.kt)("inlineCode",{parentName:"p"},"children")," array of object ",(0,i.kt)("inlineCode",{parentName:"p"},"3")),(0,i.kt)("p",null,"The Object ",(0,i.kt)("inlineCode",{parentName:"p"},"3")," that was assigned to the ",(0,i.kt)("inlineCode",{parentName:"p"},"children")," array of object ",(0,i.kt)("inlineCode",{parentName:"p"},"8")," is really just a ",(0,i.kt)("strong",{parentName:"p"},"reference")," to Object ",(0,i.kt)("inlineCode",{parentName:"p"},"3")," in memory\u2026 meaning its ",(0,i.kt)("inlineCode",{parentName:"p"},"children")," array will have the Object ",(0,i.kt)("inlineCode",{parentName:"p"},"6")," reference."),(0,i.kt)("p",null,"This logic extends to the entire array, meaning we just need to go through the array once to build out our tree!"),(0,i.kt)("p",null,"Here is a potential non-recursive solution based on this idea:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"const flat = [\n  { id: 1, parentId: 3 },\n  { id: 3, parentId: 8 },\n  { id: 4, parentId: 6 },\n  { id: 6, parentId: 3 },\n  { id: 7, parentId: 6 },\n  { id: 8, parentId: null },\n  { id: 10, parentId: 8 }, \n  { id: 13, parentId: 14 },\n  { id: 14, parentId: 10 }\n]\n\n// Create root for top-level node(s)\nconst root = [];\n\nflat.forEach(node => {\n  // No parentId means top level\n  if (!node.parentId) return root.push(node);\n  \n  // Insert node as child of parent in flat array\n  const parentIndex = flat.findIndex(el => el.id === node.parentId);\n  if (!flat[parentIndex].children) {\n    return flat[parentIndex].children = [node];\n  }\n  \n  flat[parentIndex].children.push(node);\n});\n\nconsole.log(root);\n")),(0,i.kt)("p",null,"Nice and simple, and we only iterate through the array once!"),(0,i.kt)("p",null,"There is one bonus optimization I would like to make: the ",(0,i.kt)("inlineCode",{parentName:"p"},"findIndex")," function we use each time through the loop isn\u2019t a big deal for the small example tree, but this could actually get expensive if we\u2019re working with a large tree. Let\u2019s create an object to cache found parent locations."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'// Create root for top-level node(s)\nconst root = [];\n// Cache found parent index\nconst map = {};\n\nflat.forEach(node => {\n  // No parentId means top level\n  if (!node.parentId) return root.push(node);\n  \n  // Insert node as child of parent in flat array\n  let parentIndex = map[node.parentId];\n  if (typeof parentIndex !== "number") {\n    parentIndex = flat.findIndex(el => el.id === node.parentId);\n    map[node.parentId] = parentIndex;\n  }\n  \n  if (!flat[parentIndex].children) {\n    return flat[parentIndex].children = [node];\n  }\n  \n  flat[parentIndex].children.push(node);\n});\n\nconsole.log(root);\n')),(0,i.kt)("p",null,"Success! We have accomplished our tree build without implementing a recursive function."))}u.isMDXComponent=!0},8580:function(e,n,t){"use strict";n.Z=t.p+"assets/images/example_tree_structure-5b45ae46077916a2e5b096aadab36848.png"}}]);